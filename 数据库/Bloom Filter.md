# Bloom Filter

## 布隆过滤器

常用于大数据的排重，比如email，url 等。 核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。 优点：空间和时间效率都很高。 缺点：随着存入的元素数量增加，误算率随之增加。

## Bloom Filter 原理

下面来分析下它的实现原理。

* 官方的说法是：它是一个保存了很长的二级制向量，同时结合 Hash 函数实现的。

听起来比较绕，但是通过一个图就比较容易理解了。

[![img](https://camo.githubusercontent.com/c8b2708c2037184733be9c73f5580c7ef84d441e/68747470733a2f2f7773332e73696e61696d672e636e2f6c617267652f303036744e6252776c793166786a6f326b7536326a6a3330657730627a7765752e6a7067)](https://camo.githubusercontent.com/c8b2708c2037184733be9c73f5580c7ef84d441e/68747470733a2f2f7773332e73696e61696d672e636e2f6c617267652f303036744e6252776c793166786a6f326b7536326a6a3330657730627a7765752e6a7067)

如图所示：

- 首先需要初始化一个二进制的数组，长度设为 L（图中为 8），同时初始值全为 0 。
- 当写入一个 `A1=1000` 的数据时，需要进行 H 次 `hash` 函数的运算（这里为 2 次）；与 HashMap 有点类似，通过算出的 `HashCode` 与 L 取模后定位到 0、2 处，将该处的值设为 1。
- `A2=2000` 也是同理计算后将 `4、7` 位置设为 1。
- 当有一个 `B1=1000` 需要判断是否存在时，也是做两次 Hash 运算，定位到 0、2 处，此时他们的值都为 1 ，所以认为 `B1=1000` 存在于集合中。
- 当有一个 `B2=3000` 时，也是同理。第一次 Hash 定位到 `index=4` 时，数组中的值为 1，所以再进行第二次 Hash 运算，结果定位到 `index=5` 的值为 0，所以认为 `B2=3000` 不存在于集合中。

整个的写入、查询的流程就是这样，汇总起来就是：

对写入的数据做 H 次 hash 运算定位到数组中的位置，同时将数据改为 1 。当有数据查询时也是同样的方式定位到数组中。 一旦其中的有一位为 **0** 则认为数据**肯定不存在于集合**，否则数据**可能存在于集合中**。

所以布隆过滤有以下几个特点：

1. 只要返回数据不存在，则肯定不存在。
2. 返回数据存在，但只能是大概率存在。
3. 同时不能清除其中的数据。

第一点应该都能理解，重点解释下 2、3 点。

为什么返回存在的数据却是可能存在呢，这其实也和 `HashMap` 类似。

在有限的数组长度中存放大量的数据，即便是再完美的 Hash 算法也会有冲突，所以有可能两个完全不同的 `A、B` 两个数据最后定位到的位置是一模一样的。

这时拿 B 进行查询时那自然就是误报了。

删除数据也是同理，当我把 B 的数据删除时，其实也相当于是把 A 的数据删掉了，这样也会造成后续的误报。

基于以上的 `Hash` 冲突的前提，所以 `Bloom Filter` 有一定的误报率，这个误报率和 `Hash` 算法的次数 H，以及数组长度 L 都是有关的。

## 源码分析

那就来看看 `Guava` 它是如何实现的。

构造方法中有两个比较重要的参数，一个是预计存放多少数据，一个是可以接受的误报率。 我这里的测试 demo 分别是 1000W 以及 0.01。

[![img](https://camo.githubusercontent.com/f984a9fd4231e2fdcffb888da1937024d7a7abd9/68747470733a2f2f7773332e73696e61696d672e636e2f6c617267652f303036744e6252776c793166786a703972656f6d616a333079713063716a76392e6a7067)](https://camo.githubusercontent.com/f984a9fd4231e2fdcffb888da1937024d7a7abd9/68747470733a2f2f7773332e73696e61696d672e636e2f6c617267652f303036744e6252776c793166786a703972656f6d616a333079713063716a76392e6a7067)

`Guava` 会通过你预计的数量以及误报率帮你计算出你应当会使用的数组大小 `numBits` 以及需要计算几次 Hash 函数 `numHashFunctions` 。

这个算法计算规则可以参考维基百科。

### put 写入函数

真正存放数据的 `put` 函数如下：

[![img](https://camo.githubusercontent.com/74739d7317895e2c208642141277c4a23292c371/68747470733a2f2f7773312e73696e61696d672e636e2f6c617267652f303036744e6252776c793166786a7067353568737a6a3330736f3038326162782e6a7067)](https://camo.githubusercontent.com/74739d7317895e2c208642141277c4a23292c371/68747470733a2f2f7773312e73696e61696d672e636e2f6c617267652f303036744e6252776c793166786a7067353568737a6a3330736f3038326162782e6a7067)

- 根据 `murmur3_128` 方法的到一个 128 位长度的 `byte[]`。
- 分别取高低 8 位的到两个 `hash` 值。
- 再根据初始化时的到的执行 `hash` 的次数进行 `hash` 运算。

```
bitsChanged |= bits.set((combinedHash & Long.MAX_VALUE) % bitSize);
```

其实也是 `hash取模`拿到 `index` 后去赋值 1.

重点是 `bits.set()` 方法。

[![img](https://camo.githubusercontent.com/dcbddae8e5a1fe3acf3081a8950044290c97d49b/68747470733a2f2f7773322e73696e61696d672e636e2f6c617267652f303036744e6252776c793166786a706c36756968306a33306d333064786d7a392e6a7067)](https://camo.githubusercontent.com/dcbddae8e5a1fe3acf3081a8950044290c97d49b/68747470733a2f2f7773322e73696e61696d672e636e2f6c617267652f303036744e6252776c793166786a706c36756968306a33306d333064786d7a392e6a7067)

其实 set 方法是 `BitArray` 中的一个函数，`BitArray` 就是真正存放数据的底层数据结构。

利用了一个 `long[] data` 来存放数据。

所以 `set()` 时候也是对这个 `data` 做处理。

[![img](https://camo.githubusercontent.com/4e7957dd78db2a65ba14a10645304167d1574676/68747470733a2f2f7773332e73696e61696d672e636e2f6c617267652f303036744e6252776c793166786a706e6f626f64766a3330697a3036767766372e6a7067)](https://camo.githubusercontent.com/4e7957dd78db2a65ba14a10645304167d1574676/68747470733a2f2f7773332e73696e61696d672e636e2f6c617267652f303036744e6252776c793166786a706e6f626f64766a3330697a3036767766372e6a7067)

- 在 `set` 之前先通过 `get()` 判断这个数据是否存在于集合中，如果已经存在则直接返回告知客户端写入失败。
- 接下来就是通过位运算进行`位或赋值`。
- `get()` 方法的计算逻辑和 set 类似，只要判断为 0 就直接返回存在该值。

### mightContain 是否存在函数

[![img](https://camo.githubusercontent.com/c0504035f693eb8a5a1aee4a539002c3ae951f6f/68747470733a2f2f7773322e73696e61696d672e636e2f6c617267652f303036744e6252776c793166786a70726b7a756c786a33306f3430387761626b2e6a7067)](https://camo.githubusercontent.com/c0504035f693eb8a5a1aee4a539002c3ae951f6f/68747470733a2f2f7773322e73696e61696d672e636e2f6c617267652f303036744e6252776c793166786a70726b7a756c786a33306f3430387761626b2e6a7067)

前面几步的逻辑都是类似的，只是调用了刚才的 `get()` 方法判断元素是否存在而已。
