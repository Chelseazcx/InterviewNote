# 牛客刷题笔记

## Java指令

java用来运行一个.class文件

javadoc用来生成api文档

jar用来生成jar包

javac用来把.java文件编译为.class文件

java.exe是java虚拟机

jdb.exe是java的调试器

javaprof.exe是剖析工具

## System.out.println

System是java.lang中的一个类，out是System内的一个成员变量，这个变量是一个java.io.PrintStream类的对象，println是一个方法。



## JDK三个ClassLoader

JDK中提供了三个ClassLoader，根据层级从高到低为：

1. Bootstrap ClassLoader，主要加载JVM自身工作需要的类。

2. Extension ClassLoader，主要加载%JAVA_HOME%\lib\ext目录下的库类。

3. Application ClassLoader，主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是**ClassLoader.getSystemClassLoader()** 的返回值。（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath）


## 双亲委托模型

JVM 加载类的实现方式，我们称为 **双亲委托模型**：

如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委托给自己的父加载器，每一层的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的**Bootstrap ClassLoader**中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。

**双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。**

假设有一个开发者自己编写了一个名为**Java.lang.Object**的类，想借此欺骗JVM。现在他要使用**自定义ClassLoader**来加载自己编写的**java.lang.Object**类。然而幸运的是，**双亲委托模型**不会让他成功。因为JVM会优先在**Bootstrap ClassLoader**的路径下找到**java.lang.Object**类，并载入它

## 编码

 编码就是一个编号(数字)到字符的一种映射关系，就仅仅是一种一对一的映射而已，可以理解成一个很大的对应表格。 java默认的字符集是Unicode（占两个字节byte，一个字节=8比特位bit，所以每个Unicode占用16比特位）

编码格式：编码格式 是用来序列化或存储**编码**中提到的那个“编号(数字)”的一种“格式”，包括gbk和utf-8

- gbk： 是指中国的中文字符，其它它包含了简体中文与繁体中文字符
- UTF-8： 它是一种全国家通过的一种编码

Java语言中，中文字符所占的字节数取决于字符的编码方式，一般情况下:

- 采用ISO8859-1编码方式时，一个中文字符与一个英文字符一样只占1个字节；
- 采用GB2312或GBK编码方式时，一个中文字符占2个字节；
- 而采用UTF-8编码方式时，一个中文字符会占3个字节。

Java中的byte，short，char进行计算时都会提升为int类型。

算法包括0个或多个输入，1个或多个输出，中间有穷个处理过程。
存储结构不属于算法结构

1. Java中是以补码表示一个数，所以表示形式是补码，不是原码

2. 第一位正负位，1表示负，0表示正。

3. 原码：一个数的二进制表示。

   ```
    3的原码00000011   -3的 原码 10000011
   ```

4. 反码：正数原码本身。负数原码按位取反（符号位不变）。

   ```
    3的反码00000011   -3的反码11111100
   ```

5. 补码：正数是原码本身。负数反码加1。

   ```
    3的补码是00000011  -3的补码是11111101
   ```



## 管道

管道实际上是一种固定大小的缓冲区，管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。它类似于通信中半双工信道的进程通信机制，一个管道可以实现双向 的数据传输，而同一个时刻只能最多有一个方向的传输，不能两个方向同时进行。管道的容 量大小通常为内存上的一页，它的大小并不是受磁盘容量大小的限制。当管道满时，进程在 写管道会被阻塞，而当管道空时，进程读管道会被阻塞,选A，而C不能同时进行双向传输

对于管道，有下面这几种类型：

①普通管道（PIPE）：通常有两种限制，一是单工，即只能单向传输；二是血缘，即常用于父子进程间（或有血缘关系的进程间）

②流管道（s_pipe）：去除了上述的第一种限制，实现了双向传输。

③命名管道（name_pipe）：去除了上述的第二种限制，实现了无血缘关系的不同进程间通信。

显然，要求是对于不同的服务器之间的通信，是要要求全双工形式的，而管道只能是半双工，虽然可以双向，但是同一时间只能有一个方向传输，全双工和半双工的区别可以如下图示理解：

![img](https://uploadfiles.nowcoder.com/images/20180322/4846014_1521723853172_FF523AF3E7DA7B365BEA995386A30039)

## 数据库三种模式

1.模式，也称概念模式、逻辑模式，它是DB中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个模式。

2.外模式，也称子模式、用户模式，能够看到局部数据逻辑结构，外模式通常是模式的逻辑子集。一个数据库有多个外模式。

3.内模式，也称存储模式，是数据库物理结构和存储方式的描述。一个数据库只有一个内模式。

```
SQL语句中select对应投影运算，where语句对应选择运算，from后面的表对应连接运算，其中
from a， b表示笛卡尔集
from a join b on a.A=b.A对应自然连接
```

## 内部类

1. 为什么使用内部类?

使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响

​	   1.1. 使用内部类最大的优点就在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性:

- 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独。
- 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
- 创建内部类对象的时刻并不依赖于外围类对象的创建。
- 内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
- 内部类提供了更好的封装，除了该外围类，其他类都不能访问。

2. 内部类分类:

(一).成员内部类:

```
public class Outer{
        private int age = 99;
        String name = "Coco";
        public class Inner{
            String name = "Jayden";
            public void show(){
                System.out.println(Outer.this.name);
                System.out.println(name);
                System.out.println(age);
            }
        }
        public Inner getInnerClass(){
            return new Inner();
        }
        public static void main(String[] args){
            Outer o = new Outer();
            Inner in = o.new Inner();
            in.show();
        }
    }
```

1. Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 public 、 protected 、 private 等
2. Inner 类中定义的 show() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性age
3. 定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：内部类 对象名 = 外部类对象.new 内部类( );
4. 编译上面的程序后，会发现产生了两个 .class 文件: Outer.class,Outer$Inner.class{}
5. 成员内部类中不能存在任何 static 的变量和方法,可以定义常量:

- 因为非静态内部类是要依赖于外部类的实例,而静态变量和方法是不依赖于对象的,仅与类相关,简而言之:在加载静态域时,根本没有外部类,所在在非静态内部类中不能定义静态域或方法,编译不通过;非静态内部类的作用域是实例级别
- 常量是在编译器就确定的,放到所谓的常量池了

★★友情提示:

1. 外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法;
2. 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，

可以使用 this 关键字,如:Outer.this.name

(二).静态内部类: 

是 static 修饰的内部类

1. 静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问 
2. 如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员
3. 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 = new 内部类();


```
public class Outer{
            private int age = 99;
            static String name = "Coco";
            public static class Inner{
                String name = "Jayden";
                public void show(){
                    System.out.println(Outer.name);
                    System.out.println(name);                  
                }
            }
            public static void main(String[] args){
                Inner i = new Inner();
                i.show();
            }
        }
```



(三).方法内部类：

其作用域仅限于方法内，方法外部无法访问该内部类

1. 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的
2. 只能访问方法中定义的 final 类型的局部变量,因为:当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在,直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量;==>使用final修饰符不仅会保持对象的引用不会改变,而且编译器还会持续维护这个对象在回调方法中的生命周期.局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数;防止被篡改数据,而导致内部类得到的值不一致


```
 /*
        使用的形参为何要为 final???
         在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，
         也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，
         毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解
         和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变
         */
        public class Outer{
            public void Show(){
                final int a = 25;
                int b = 13;
                class Inner{
                    int c = 2;
                    public void print(){
                        System.out.println("访问外部类:" + a);
                        System.out.println("访问内部类:" + c);
                    }
                }
                Inner i = new Inner();
                i.print();
            }
            public static void main(String[] args){
                Outer o = new Outer();
                o.show();
            }
        }    
```



**(3).注意:在JDK8版本之中,方法内部类中调用方法中的局部变量,可以不需要修饰为 final,匿名内部类也是一样的，主要是JDK8之后增加了 Effectively final 功能**[**http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html**
该类的定义会立即消失，所以匿名内部类是不能够被重复使用;
(3).使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口;
(4).匿名内部类中是不能定义构造函数的,匿名内部类中不能存在任何的静态成员变量和静态方法;
(5).匿名内部类中不能存在任何的静态成员变量和静态方法,匿名内部类不能是抽象的,它必须要实现继承的类或者实现的接口的所有抽象方法
(6).匿名内部类初始化:使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果


```
public class OuterClass {
            public InnerClass getInnerClass(final int   num,String str2){
                return new InnerClass(){
                    int number = num + 3;
                    public int getNumber(){
                        return number;
                    }
                };        /* 注意：分号不能省 */
            }
            public static void main(String[] args) {
                OuterClass out = new OuterClass();
                InnerClass inner = out.getInnerClass(2, "chenssy");
                System.out.println(inner.getNumber());
            }
        }
        interface InnerClass {
            int getNumber();
        }         
```







## HashTable和HashMap区别

①继承不同。

```
public class Hashtable extends Dictionary implements Map public class HashMap extends AbstractMap implements Map
```

②Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。

③Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。

④两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。

⑤哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。

⑥Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 



## 基本类型默认值

| 默认值     | 存储需求（字节）  | 取值范围 | 示例           |                    |
| ------- | --------- | ---- | ------------ | ------------------ |
| byte    | 0         | 1    | -2^7—2^7-1   | byte b=10;         |
| char    | ‘ \u0000′ | 2    | 0—2^16-1     | char c=’c’ ;       |
| short   | 0         | 2    | -2^15—2^15-1 | short s=10;        |
| int     | 0         | 4    | -2^31—2^31-1 | int i=10;          |
| long    | 0         | 8    | -2^63—2^63-1 | long o=10L;        |
| float   | 0.0f      | 4    | -2^31—2^31-1 | float f=10.0F      |
| double  | 0.0d      | 8    | -2^63—2^63-1 | double d=10.0;     |
| boolean | false     | 1    | true\false   | boolean flag=true; |



## 重载

两同两小一大原则：

方法名相同，参数类型相同

子类返回类型小于等于父类方法返回类型， 

子类抛出异常小于等于父类方法抛出异常， 

子类访问权限大于等于父类方法访问权限。



## 类、方法、成员变量和局部变量的可用修饰符

| **修饰符**           | **类** | **成员访求** | **构造方法** | **成员变量** | **局部变量** |      |
| ----------------- | ----- | -------- | -------- | -------- | -------- | ---- |
| abstract（抽象的）     | √     | √        | －        | －        | －        |      |
| static （静态的）      | －     | √        | －        | √        | －        |      |
| public（公共的）       | √     | √        | √        | √        | －        |      |
| protected（受保护的）   |       | √        | √        | √        | －        |      |
| private（私有的）      | －     | √        | √        | √        | －        |      |
| synchronized（同步的） | －     | √        | －        | －        | －        |      |
| native（本地的）       | －     | √        | －        | －        | －        |      |
| transient（暂时的）    | －     | －        | －        | √        | －        |      |
| volatie（易失的）      | －     | －        | －        | √        | －        |      |
| final（不要改变的）      | √     | √        | －        | √        | √        |      |
|                   |       |          |          |          |          |      |

| **类 修饰符**     |                   |
| ------------- | ----------------- |
| Public        | 可以从其他类中访问         |
| Abstract      | 本类不能被实例化          |
| Final         | 不能再声明子类           |
| **构造函数修饰符**   |                   |
| Public        | 可以从所有的类中访问        |
| Protected     | 只能从自己的类和它的子类中访问   |
| Private       | 只能在本类中访问          |
| **域/成员变量修饰符** |                   |
| Public        | 可以从所有的类中访问        |
| Protected     | 只能从本类和它的子类中访问     |
| Private       | 只能从本类中访问它         |
| Static        | 对该类的所有实例只能有一个域值存在 |
| transient     | 不是一个对象持久状态的一部份    |
| Volatile      | 可以被异步的线程所修改       |
| final         | 必须对它赋予初值并且不能修改它   |
| **局部变量 修饰符**  |                   |
| final         | 必须对它赋予初值并且不能修改它   |
| **方法修饰符**     |                   |
| Public        | 可以从所有的类中访问它       |
| Protected     | 只能从本类及其子类中访问它     |
| Private       | 只能从本类中访问它         |
| abstract      | 没有方法体，属于一个抽象类     |
| final         | 子类不能覆盖它           |
| static        | 被绑定于类本身而不是类的实例    |
| native        | 该方法由其他编程语言实现      |
| asnchronized  | 在一个线程调用它之前必须先给它加  |

**类的修饰符整合**

**一．类**

**类的修饰符：**

**Public**:可以在其他任何类中使用，默认为统一包下的任意类。

**Abstract:抽象类**，不能被实例化，可以包含抽象方法，抽象方法没有被实现，无具体功能，只能衍生子类。

**Final**:不能被继承。

**二．变量**

变量修饰符：

一个类的成员变量的声明必须在类体中，而不能在方法中，方法中声明的是**局部变量**。

1.       可访问修饰符：

2.       **static**：**类变量**：一个类所拥有的变量，不是类的每个实例有的变量。类变量是指不管类创建了多少对象，系统仅在第一次调用类的时候为类变量分配内存，所有对象共享该类的类变量，因此可以通过类本身或者某个对象来访问类变量。

3.       **final**：**常量**。

4.       **volatile**：声明一个可能同时被并存运行的几个线程所控制和修改的变量。

**实例变量**：和类变量对应，即每个对象都拥有各自独立的实例变量。

**三．方法：**（和变量对象分为实例方法和类方法，并用有无static修饰区别）

**类方法**：使用static关键字说明的方法

1. 第一次调用含类方法的类是，系统只为该类创建一个版本，这个版本被该类和该类的所有实例共享。
2. 类方法只能操作类变量，不能访问实例变量。类方法可以在类中被调用，不必创建实例来调用，当然也可以通过对象来调用。

**实例方法**：实例方法可以对当前对象的实例变量操作，而且可以访问类变量。

方法可以**重载**，要求：方法名相同，但是参数必须有区别。（参数不同可以使类型不同，顺序不同，个数不同）

方法的返回类型：若无返回类型，则声明为void.

方法中的变量作用域：

1.       成员变量：整个类。

2.       局部变量：定义起到方法块结束为止。

3.       方法参数：整个方法或者构造方法。

4.       异常处理参数：参数传递给异常处理方法。

**构造方法**：和类同名的方法。为新建对象开辟内存空间后，用于初始化新建的对象。不能用对象显式的调用。

**静态初始化器**：格式：static{<赋值语句组>}

静态初始化器与构造方法的区别： 

| 静态初始化器        | 构造方法       |
| ------------- | ---------- |
| 对类的静态域初始化     | 对新建的对象初始化  |
| 类进入内存后，系统调用执行 | 执行new后自动执行 |
| 属特殊语句（仅执行一次）  | 属特殊方法      |

**方法的修饰符：**

**抽象方法：**用abstract修饰，只有声明部分，方法体为空，具体在子类中完成。

**类方法：**静态方法，用static修饰

1.       调用时，使用类名作为前缀，而不是类的某个实例对象名

2.       不能被单独对象拥有，属于整个类共享。

3.       不能处理成员变量。

**最终方法**：用final修饰，不能被子类重新定义的方法。

**本地方法**：用native修饰的方法，表示用其他语言书写的特殊方法，包括C，C++，FORTRAN，汇编语言等。

**四．类成员的访问控制符**：

即类的方法和成员变量的访问控制符，一个类作为整体对象不可见，并不代表他的所有域和方法也对程序其他部分不可见，需要有他们的访问修饰符判断。

权限如下： 

| 访问修饰符     | 同一个类 | 同包   | 不同包，子类 | 不同包，非子类 |
| --------- | ---- | ---- | ------ | ------- |
| private   | √    |      |        |         |
| protected | √    | √    | √      |         |
| public    | √    | √    | √      | √       |
| 默认        | √    | √    |        |         |



## 类的加载顺序

1.父类静态代码块 （  java虚拟机加载类时，就会执行该块代码，故只执行一次）

2 .子类静态代码块 （  java虚拟机加载类时，就会执行该块代码，故只执行一次）

3.父类属性对象初始化

4.父类普通代码块（每次new,每次执行）

5.父类构造函数（每次new,每次执行）

6.子类 属性对象初始化

7.子类普通代码块（每次new,每次执行 **）**

8.子类构造函数（每次new,每次执行）





抛InterruptedException的代表方法有（当线程在活动之前或活动期间处于正在等待、休眠或占用状态且该线程被中断时，抛出该异常。）：  

java.lang.Object 类的 wait 方法  

java.lang.Thread 类的 sleep 方法 

 java.lang.Thread 类的 join 方法







## 反射机制

在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法;对于任意一个对象，都能够调用它的任意一个方法和属性
返回值不能作为重载的依据



## 标识符命名

标识符是以字母开头的字母数字序列：
数字是指0~9，字母指大小写英文字母、下划线（_)和美元符号（$），也可以是Unicode字符集中的字符，如汉字；字母、数字等字符的任意组合，不能包含+、- *等字符；不能使用关键字；大小写敏感



## Java中的关键字

1. 48个关键字：abstract、assert、boolean、break、byte、case、catch、char、class、continue、default、do、double、else、enum、extends、final、finally、float、for、if、implements、import、int、interface、instanceof、long、native、new、package、private、protected、public、return、short、static、strictfp、super、switch、synchronized、this、throw、throws、transient、try、void、volatile、while。
2. 2个保留字（现在没用以后可能用到作为关键字）：goto、const。
3. 3个特殊直接量：true、false、null。



## String, StringBuffer, StringBuilder

- String：字符串常量，字符串长度不可变。Java中String是immutable（不可变）的。
- StringBuffer：字符串变量（Synchronized，即线程安全）。如果要频繁对字符串内容进行修改，出于效率考虑最好使用StringBuffer，如果想转成String类型，可以调用StringBuffer的toString()方法。StringBuffer上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。
- StringBuilder：字符串变量（非线程安全）。在内部，StringBuilder对象被当作是一个包含字符序列的变长数组。java.lang.StringBuilder是一个可变的字符序列，是JDK5.0新增的。
  在大部分情况下，StringBuilder>StringBuffer。这主要是由于前者不需要考虑线程安全。




## JSP内置对象和属性

1. request对象
   客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。
2. response对象
   response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。
3. session对象
   session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例。
4. out对象
   out对象是JspWriter类的实例,是向客户端输出内容常用的对象。
5. page对象
   page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例。
6. application对象
   application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。
7. exception对象
   exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象。
8. pageContext对象
   pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。
9. config对象
   config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）

### forward & redirect:

1.从地址栏显示来说
forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.
redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.

2.从数据共享来说
forward:转发页面和转发到的页面可以共享request里面的数据.
redirect:不能共享数据.

3.从运用地方来说
forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.

4.从效率来说
forward:高.
redirect:低.



## java.lang包中不能被继承的类

```
public final class Byte
public final class Character
public static final class Character.UnicodeBlock
public final class Class<T>
public final class Compile
public final class Double
public final class Float
public final class Integer
public final class Long
public final class Math
public final class ProcessBuilder
public final class RuntimePermission
public final class Short
public final class StackTraceElement
public final class StrictMath
public final class String
public final class StringBuffer
public final class StringBuilder
public final class System
public final class Void
```



## Queue

1. LinkedBlockingQueue：基于链接节点的可选限定的blocking queue 。 这个队列排列元素FIFO（先进先出）。 队列的头部是队列中最长的元素。 队列的尾部是队列中最短时间的元素。 新元素插入队列的尾部，队列检索操作获取队列头部的元素。 链接队列通常具有比基于阵列的队列更高的吞吐量，但在大多数并发应用程序中的可预测性能较低。
   blocking queue说明：不接受null元素；可能是容量有限的；实现被设计为主要用于生产者 - 消费者队列；不支持任何类型的“关闭”或“关闭”操作，表示不再添加项目实现是线程安全的；
2. PriorityQueue：
   2.1. 基于优先级堆的无限优先级queue 。 优先级队列的元素根据它们的有序natural ordering ，或由一个Comparator在队列构造的时候提供，这取决于所使用的构造方法。 优先队列不允许null元素。 依靠自然排序的优先级队列也不允许插入不可比较的对象（这样做可能导致ClassCastException ）。
   2.2. 该队列的头部是相对于指定顺序的最小元素。 如果多个元素被绑定到最小值，那么头就是这些元素之一 - 关系被任意破坏。 队列检索操作poll ， remove ， peek和element访问在队列的头部的元件。
   2.3. 优先级队列是无限制的，但是具有管理用于在队列上存储元素的数组的大小的内部容量 。 它始终至少与队列大小一样大。 当元素被添加到优先级队列中时，其容量会自动增长。 没有规定增长政策的细节。
   2.4. 该类及其迭代器实现Collection和Iterator接口的所有可选方法。 方法iterator()中提供的迭代器不能保证以任何特定顺序遍历优先级队列的元素。 如果需要有序遍历，请考虑使用Arrays.sort(pq.toArray()) 。
   2.5. 请注意，此实现不同步。 如果任何线程修改队列，多线程不应同时访问PriorityQueue实例。 而是使用线程安全的PriorityBlockingQueue类。
   实现注意事项：此实现提供了O（log(n)）的时间入队和出队方法（ offer ， poll ， remove()和add ）; remove(Object)和contains(Object)方法的线性时间; 和恒定时间检索方法（ peek ， element和size ）。
3. ConcurrentLinkedQueue：基于链接节点的无界并发deque(deque是双端队列) 。 并发插入，删除和访问操作可以跨多个线程安全执行。 A ConcurrentLinkedDeque是许多线程将共享对公共集合的访问的适当选择。像大多数其他并发集合实现一样，此类不允许使用null元素。

客户端通过new Socket()方法创建通信的Socket对象
服务器端通过new ServerSocket()创建TCP连接对象  accept接纳客户端请求

Java字节码（byte code）是Java源文件编译产生的中间文件



## JDK，JRE，JVM区别与联系

- JDK : Java Development ToolKit(Java开发工具包)。
  JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。 最主流的JDK是Sun公司发布的JDK，除了Sun之外，还有很多公司和组织都开发了属于自己的JDK，例如国外IBM公司开发了属于自己的JDK，国内淘宝也开发了属于自己的JDK，各个组织开发自己的JDK都是为了在某些方面得到一些提高，以适应自己的需求，比如IBM的JDK据说运行效率就比SUN的JDK高的多。

### JDK有以下三种版本：

- J2SE，standard edition，标准版，是我们通常用的一个版本J2EE
- enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序J2ME
- micro edtion，主要用于移动设备、嵌入式设备上的java应用程序 
  ​     

我们常常用JDK来代指Java API，Java API是Java的应用程序接口，
其实就是前辈们写好的一些java Class，包括一些重要的语言结构 
以及基本图形，网络和文件I/O等等，我们在自己的程序中，调用前 辈们写好的这些Class，来作为我们自己开发的一个基础。当然，现在已经有越来越多的性能更好或者功能更强大的第三方类库供我们使用。

- JRE:Java Runtime Enviromental(java运行时环境)。
  也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。 
- JVM：Java Virtual Mechinal(JAVA虚拟机)。 JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM的主要工作是解释自己的指令集 （即字节码）并映射到本地的 CPU 的指令集或 OS的系统调用。 Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。




## 运算符优先级

- 单目运算符：+，-，++，--
- 算数运算符：+，-，*，/，%
- 移位运算符：<<,>>
- 关系运算符：>,<,>=,<=,==,!=
- 位运算符：&，|，~，^,
- 逻辑运算符：&&，||
- 三目运算符：表达式1？表达式2：表达式3;
- 赋值运算符：=等

口诀：淡云一笔安洛三福 单目>算数运算符>移位>比较>按位>逻辑>三目>赋值



## 时间/空间复杂度

### 一、时间复杂度  

（1）时间频度 
​	一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行[测试](http://lib.csdn.net/base/softwaretest)才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 
（2）时间复杂度 
​	在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 
​	一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 
​	在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。 


按数量级递增排列，常见的时间复杂度有： 

- 常数阶O(1)
- 对数阶O(log2n)
- 线性阶O(n)
- 线性对数阶O(nlog2n)
- 平方阶O(n2)
- 立方阶O(n3)
- k次方阶O(nk)
- 指数阶O(2n)

随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 


### 二、空间复杂度 

与时间复杂度类似，空间复杂度是指算法在计算机内执行时所需存储空间的度量。记作: 
S(n)=O(f(n)) 
我们一般所讨论的是除正常占用内存开销外的辅助存储单元规模

 

### 三、常见算法时间复杂度

- O(1): 表示算法的运行时间为常量
- O(n): 表示该算法是线性算法
- O(㏒2n): 二分查找算法
- O(n2): 对数组进行排序的各种简单算法，例如直接插入排序的算法。
- O(n3): 做两个n阶矩阵的乘法运算
- O(2n): 求具有n个元素集合的所有子集的算法
- O(n!): 求具有N个元素的全排列的算法

优<- - - - - - - - - <劣

O(1)<O(㏒2n)<O(n)<O(n2)<O(2n)

时间复杂度按数量级递增排列依次为：常数阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶O(n2)、立方阶O(n3)、……k次方阶O(nk)、指数阶O(2n)。

 

四、算法的时间复杂度（计算实例）

定义：如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)，它是n的某一函数 T(n)称为这一算法的“时间复杂性”。

当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。

我们常用大O表示法表示时间复杂性，注意它是某一个算法的时间复杂性。大O表示只是说有上界，由定义如果f(n)=O(n)，那显然成立f(n)=O(n^2)，它给你一个上界，但并不是上确界，但人们在表示的时候一般都习惯表示前者。

此外，一个问题本身也有它的复杂性，如果某个算法的复杂性到达了这个问题复杂性的下界，那就称这样的算法是最佳算法。

“大O记法”：在这种描述中使用的基本参数是 n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级 (order)，比如说“二分检索是 O(logn)的”,也就是说它需要“通过logn量级的步骤去检索一个规模为n的数组”记法 O ( f(n) )表示当 n增大时，运行时间至多将以正比于 f(n)的速度增长。

这种渐进估计对算法的理论分析和大致比较是非常有价值的，但在实践中细节也可能造成差异。例如，一个低附加代价的O(n2)算法在n较小的情况下可能比一个高附加代价的 O(nlogn)算法运行得更快。当然，随着n足够大以后，具有较慢上升函数的算法必然工作得更快。

O(1)

```
Temp=i;
i=j;
j=temp;   
```

以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。如果算法的执行时 间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。



O(n^2)

2.1. 交换i和j的内容

```
sum=0；                 （一次）
for(i=1;i<=n;i++)       （n次 ）
	for(j=1;j<=n;j++) （n^2次 ）
    	sum++；       （n^2次 ）

T(n)=2n^2+n+1 =O(n^2)
```

2.2.  

```
    for (i=1;i<n;i++)
    {
        y=y+1;         ①   
        for (j=0;j<=(2*n);j++)    
           x++;        ②      
    }         

解： 语句1的频度是n-1
          语句2的频度是(n-1)*(2n+1)=2n^2-n-1
          f(n)=2n^2-n-1+(n-1)=2n^2-2
          
该程序的时间复杂度T(n)=O(n^2).         
  

```



O(n)                                                      

2.3.

```
    a=0;
    b=1;                      ①
    for (i=1;i<=n;i++) ②
    {  
       s=a+b;　　　　③
       b=a;　　　　　④  
       a=s;　　　　　⑤
    }

解： 语句1的频度：2,        
          语句2的频度： n,        
          	语句3的频度： n-1,        
          	语句4的频度：n-1,    
         	 语句5的频度：n-1,                                  
T(n)=2+n+3(n-1)=4n-1=O(n).
```

                                                                   

O(log2n )

2.4.

```
     i=1;       ①
    while (i<=n)
       i=i*2; ②
       
解： 语句1的频度是1,  
          设语句2的频度是f(n),   则：2^f(n)<=n;f(n)<=log2n    
          取最大值f(n)= log2n,
T(n)=O(log2n )
```



O(n^3)

2.5. 

```
    for(i=0;i<n;i++)
    {  
       for(j=0;j<i;j++)  
       {
          for(k=0;k<j;k++)
             x=x+2;  
       }
    }

解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n^3).
```

我们还应该区分算法的最坏情况的行为和期望行为。如快速排序的最 坏情况运行时间是 O(n^2)，但期望时间是 O(nlogn)。通过每次都仔细 地选择基准值，我们有可能把平方情况 (即O(n^2)情况)的概率减小到几乎等于 0。在实际中，精心实现的快速排序一般都能以 (O(nlogn)时间运行。

下面是一些常用的记法：

访问数组中的元素是常数时间操作，或说O(1)操作。一个算法如 果能在每个步骤去掉一半数据元素，如二分检索，通常它就取 O(logn)时间。用strcmp比较两个具有n个字符的串需要O(n)时间 。常规的矩阵乘算法是O(n^3)，因为算出每个元素都需要将n对 元素相乘并加到一起，所有元素的个数是n^2。

指数时间算法通常来源于需要求出所有可能结果。例如，n个元 素的集合共有2n个子集,所以要求出所有子集的算法将是O(2n)的 。指数算法一般说来是太复杂了，除非n的值非常小，因为，在 这个问题中增加一个元素就导致运行时间加倍。不幸的是，确实有许多问题 (如著名 的“巡回售货员问题” )，到目前为止找到的算法都是指数的。如果我们真的遇到这种情况， 通常应该用寻找近似最佳结果的算法替代之。



## 结构型模式

结构型模式是描述如何将类对象结合在一起，形成一个更大的结构，结构模式描述两种不同的东西：类与类的实例。故可以分为类结构模式和对象结构模式。

在GoF设计模式中，结构型模式有：

1.适配器模式 Adapter

  适配器模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

  两个成熟的类需要通信，但是接口不同，由于开闭原则，我们不能去修改这两个类的接口，所以就需要一个适配器来完成衔接过程。

2.桥接模式 Bridge

  桥接模式将抽象部分与它的实现部分分离，是它们都可以独立地变化。它很好的支持了开闭原则和组合锯和复用原则。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这些多角度分离出来让他们独立变化，减少他们之间的耦合。

3.组合模式 Composite

  组合模式将对象组合成树形结构以表示部分-整体的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。

4.装饰模式 Decorator

装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，它比生成子类更灵活。也可以这样说，装饰模式把复杂类中的核心职责和装饰功能区分开了，这样既简化了复杂类，有去除了相关类中重复的装饰逻辑。** 装饰模式没有通过继承原有类来扩展功能，但却达到了一样的目的，而且比继承更加灵活，所以可以说装饰模式是继承关系的一种替代方案。**

5.外观模式 Facade

 外观模式为子系统中的一组接口提供了同意的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

外观模式中，客户对各个具体的子系统是不了解的，所以对这些子系统进行了封装，对外只提供了用户所明白的单一而简单的接口，用户直接使用这个接口就可以完成操作，而不用去理睬具体的过程，而且子系统的变化不会影响到用户，这样就做到了信息隐蔽。

6.享元模式 Flyweight

 享元模式为运用共享技术有效的支持大量细粒度的对象。因为它可以通过共享大幅度地减少单个实例的数目，避免了大量非常相似类的开销。.

      享元模式是一个类别的多个对象共享这个类别的一个对象，而不是各自再实例化各自的对象。这样就达到了节省内存的目的。

7.代理模式 Proxy

为其他对象提供一种代理，并由代理对象控制对原对象的引用，以间接控制对原对象的访问。



u-g-o：用户-组内用户-其他用户

r-w-x：用4-2-1表示。

组外成员o的权限为只读：r-- = 4

所有者a有全部权限：rwx; = 7

组内g的权限为读与写:rw- = 6



1. 物理层： RJ45 、 CLOCK 、 IEEE802.3 （中继器，集线器，网关） - 
2. 数据链路： PPP 、 FR 、 HDLC 、 VLAN 、 MAC （网桥，交换机） - 
3. 网络层： IP 、 ICMP 、 ARP 、 RARP 、 OSPF 、 IPX 、 RIP 、 IGRP 、 （路由器） - 
4. 传输层： TCP 、 UDP 、 SPX - 
5. 会话层： NFS 、 SQL 、 NETBIOS 、 RPC - 
6. 表示层： JPEG 、 MPEG 、 ASII - 
7. 应用层： FTP 、 DNS 、 Telnet 、 SMTP 、 HTTP 、 WWW 、 NFS

在内存小于2G的情况下，交换分区应为内存的2倍，超过2G的话，交换分区为物理内存加上2G



man的级别： 
1：查看命令的帮助 
2：查看可被内核调用的函数的帮助 
3：查看函数和函数库的帮助 
4：查看特殊文件的帮助（主要是/dev目录下的文件） 
5：查看配置文件的帮助 
6：查看游戏的帮助 
7：查看其它杂项的帮助 
8：查看系统管理员可用命令的帮助 
man -f 【命令】–可以查看这个命令有哪些级别



$# 是传给脚本的参数个数

$0是脚本本身的名字

$1是传递给该shell脚本的第一个参数

$2是传递给该shell脚本的第二个参数

$@ 是传给脚本的所有参数的列表

$* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个

$$ 是脚本运行的当前进程ID号

$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误



## Linux启动流程：

1，BIOS加电自检；

2，从硬盘0柱面 0磁道 第一扇区读512字节的MBR主引导记录；

3，运行引导程序Grub并根据其配置加载kernel镜像后初始化；

4，根据/etc/inittab中系统初始化配置执行/etc/rc.sysinit脚本；

5，根据第3步读到的runlevel值启动对应服务；

6，运行/etc/rc.local;

7，生成终端待用户登录。



cat命令：将文件内容一次全输出显示在屏幕上。

more命令：分屏显示文件内容，每次只显示一屏，只允许向前浏览。

less命令：与more相似，并且支持向前，向后浏览。

## 内部类

1.静态内部类：不可以访问外部的非静态资源；可以有public static abstract class Demo

2.成员内部类：可以访问外部所有资源，但是本身内部不可有静态属性（因为本身就依靠外部类的实例化）

3.局部内部类：不可被访问修饰符和static修饰，只能访问final变量和行参；(a)局部静态内部类，在外部类的静态方法中，(b)局部内部类，在外部类的一般方法中

4.匿名内部类：(a)没有构造器，没有静态资源，无法被访问修饰符，static修饰。(b)只能创建匿名内部类的一个实例。(c)创建的时候一定是在new后面。

5.创建方式：(a)insideOne ei = new InsideOne()；在别的类中使用时，需要导入import EnclosingOne	.InsideOne

​	(b)EncloseOne.InsideOne ei = eo.new InsideOne();成员内部类；EnclosingOne.InsideOne obj1 = new Enclosing().new InsideOne();

​	(c)Enclosingone.insideTwo obj2 = new Enclosingone.InsideTwo();静态内部类；



HttpServlet容器响应Web客户请求流程如下：

1）Web客户向Servlet容器发出Http请求；

2）Servlet容器解析Web客户的Http请求；

3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；

4）Servlet容器创建一个HttpResponse对象；

5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；

6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；

7）HttpServlet调用HttpResponse的有关方法，生成响应数据；

8）Servlet容器把HttpServlet的响应结果传给Web客户。



Lanbda表达式的主要作用就是代替匿名内部类的繁琐语法， 它由三部分组成：

（1） 形参列表。形参列表允许省略形参类型。如果形参列表中只有一个参数，甚至连形参列表的圆括号也可以省略。

（2） 箭头（→）。必须通过英文中画线和大于符号组成。

（3）代码块。如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号，那么那条语句就不要用花括号表示语句结束。



## sleep和wait的区别有：

  1，这两个方法来自不同的类分别是Thread和Object
  2，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得敏感词线程可以使用同步控制块或者方法。
  3，wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用

   4,sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常



## 枚举：

public enum 名{

枚举量     --->    常量，符合标识符书写

}      (必须作为第一条语句)

枚举类型是class，有构造方法(只能是private，不允许public)，方法，字段

获取枚举类型中的常量 -- > 枚举名.常量

枚举类型的每一个值都是一个对象，枚举类型实际上是类

eg. enum  color{

RED, BLUE, YELLOW;

相当于：public static final color RED = new color()；

​		...

}

## Servet体系结构

![servet](https://uploadfiles.nowcoder.net/images/20170518/1562929_1495091266467_AA89EDF1B0D43CAA9A893C73A1615398)







