# 二叉树路径

LeetCode 112 Path Sum

给定一棵二叉树，判断是否存在从根节点到叶子节点和等于sum的路径，返回true或者false

```
Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
```

递归调用，判断分两种情况，root == null表示找不到，root.left 和root.right都为null表示root为叶子节点，就需要判断val是否等于sum。其他情况往树的下一层找。

```
public boolean hasPathSum_1(TreeNode root, int sum) {
        if (root == null){
            return false;
        }
        return dfs(root,sum);
    }

    public boolean dfs(TreeNode root, int sum){
        if (root == null){
            return false;
        }

        if (root.left == null && root.right == null && root.val == sum){
            return true;
        }

        return  dfs(root.left,sum-root.val) || dfs(root.right,sum-root.val);
    }
```

LeetCode 113 Path Sum II

给定一棵二叉树，计算所有从根节点到叶子节点和等于sum的路径，并保存。

```
Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
Return:
[
   [5,4,11,2],
   [5,8,4,5]
]
```

递归调用,res保存所有的路径，temp保存从根节点到其中一条叶子节点的路径。所以，在添加val后，如果递归完返回，需要把该val删除。如果满足找到的叶子节点（root.left root.right为null），就判断val与sum是否相等，相等添加进res，不相等递归调用返回(回溯思想)。

```
public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>>  res = new ArrayList<>();
        ArrayList<Integer> temp = new ArrayList<>();

        if (root == null){
            return res;
        }

        dfs(root,sum,res,temp);
        return res;
    }

    public void dfs(TreeNode root,int sum,List<List<Integer>> res,ArrayList<Integer> temp){
        if (root == null){
            return;
        }
        temp.add(root.val);

        if (root.left == null && root.right == null){
            if (root.val == sum){
                res.add(new ArrayList<Integer>(temp));
            }
            return;
        }

        if (root.left != null){
            dfs(root.left,sum-root.val,res,temp);
            temp.remove(temp.size()-1);
        }
        if (root.right != null){
            dfs(root.right,sum-root.val,res,temp);
            temp.remove(temp.size()-1);
        }
    }
```

LeetCode 437 Path Sum III

给定一颗二叉树，计算所有从一个节点到另一个节点和等于sum的路径，并保存。节点不一定是根节点到叶子节点，但是保证从父节点到子节点。

```
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8
      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1
Return 3. The paths that sum to 8 are:
1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11
```

从根节点开始递归寻找（pathSum）。每一次递归的根节点开始寻找值等于sum（dfs）

```
 	int res = 0;
    public int pathSum(TreeNode root, int sum) {
        if (root == null){
            return 0;
        }

        dfs(root,sum);
        pathSum(root.left,sum);
        pathSum(root.right,sum);
        return res;
    }

    public void dfs(TreeNode root,int sum){
        if (root == null){
            return;
        }

        if (sum - root.val == 0) res+=1;
        dfs(root.left, sum-root.val);
        dfs(root.right, sum-root.val);
    }
```

LeetCode 257 Binary Tree Paths

给定二叉树，返回所有从根节点到叶子节点的路径

```
Input:
   1
 /   \
2     3
 \
  5
Output: ["1->2->5", "1->3"]
Explanation: All root-to-leaf paths are: 1->2->5, 1->3
```

因为没有限制条件，只需要直接递归到下一个节点并保存，所以不需要回溯，参考寻找路径等于sum II

```
public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        if (root == null)
            return res;

        dfs(root,res,"");
        return res;
    }

    public void dfs(TreeNode root, List<String> res, String s){
        if (root == null){
            return;
        }

        if (root.left == null && root.right == null){
            res.add(s + root.val);
        }

        if (root.left != null){
            dfs(root.left,res,s+root.val + "->");
        }
        if (root.right != null){
            dfs(root.right,res,s+root.val + "->");
        }
    }
```



































