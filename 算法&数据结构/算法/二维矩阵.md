# 二维矩阵算法题

LeetCode 54 Spiral Matrix

螺旋打印矩阵

```
Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]
```

```
public List<Integer> spiralOrder(int[][] matrix) {
        ArrayList<Integer> res = new ArrayList<>();
        if (matrix.length == 0){
            return res;
        }
        int rowBegin = 0;
        int rowEnd = matrix.length-1;
        int colBegin = 0;
        int colEnd = matrix[0].length-1;


        while (rowBegin <= rowEnd && colBegin<= colEnd){
            for (int j = colBegin; j<= colEnd;j++){
                res.add(matrix[rowBegin][j]);
            }
            rowBegin++;

            for (int j = rowBegin; j<= rowEnd; j++){
                res.add(matrix[j][colEnd]);
            }
            colEnd--;

            if (rowBegin <= rowEnd){
                for (int j = colEnd; j>= colBegin; j--){
                    res.add(matrix[rowEnd][j]);
                }
            }
            rowEnd--;

            if (colBegin <= colEnd){
                for (int j = rowEnd; j>= rowBegin; j--){
                    res.add(matrix[j][colBegin]);
                }
            }
            colBegin++;

        }

        return res;
    }
```

LeetCode  59 Spiral Matrix II

给定数值，从1 - N*N数值

```
Input: 3
Output:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
```

```
public int[][] generateMatrix(int n) {
        int[][] matrix = new int[n][n];

        if (n == 0){
            return matrix;
        }

        int rowBegin = 0;
        int rowEnd = matrix.length-1;
        int colBegin = 0;
        int colEnd = matrix[0].length-1;
        int index = 1;

        while (rowBegin <= rowEnd && colBegin<= colEnd){
            for (int j = colBegin; j<= colEnd;j++){
                matrix[rowBegin][j] = index++;
            }
            rowBegin++;

            for (int j = rowBegin; j<= rowEnd; j++){
                matrix[j][colEnd] = index++;
            }
            colEnd--;

            if (rowBegin <= rowEnd){
                for (int j = colEnd; j>= colBegin; j--){
                    matrix[rowEnd][j] = index++;
                }
            }
            rowEnd--;

            if (colBegin <= colEnd){
                for (int j = rowEnd; j>= rowBegin; j--){
                    matrix[j][colBegin] = index++;
                }
            }
            colBegin++;

        }

        return matrix;
    }
```

LeetCode 74 Search a 2D Matrix

每一行从左到右递增，每一列的第一个元素比上一行所有的元素都大

```
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
Output: true
```

把二维数组看成排序的一维数组，使用二分查找计算

```
public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix.length == 0){
            return false;
        }
        int row = matrix.length;
        int col = matrix[0].length;

        int begin = 0, end = row * col - 1;
        int mid_val = 0;
        int mid = 0;
        while (begin <= end) {
            mid = begin + (end - begin)/2;
            mid_val = matrix[mid/col][mid%col];
            if (mid_val == target){
                return true;
            }else if (mid_val < target){
                begin = mid+1;
            }else if (mid_val > target){
                end = mid-1;
            }
        }

        return false;
	}
```

LeetCode 240 Search a 2D Matrix II

最右元素大于同一行左侧元素，小于同一列下方元素

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
Given target = 5, return true.
Given target = 20, return false.
```

```
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length < 1 || matrix[0].length <1) {
            return false;
        }
        int col = matrix[0].length-1;
        int row = 0;
        while(col >= 0 && row <= matrix.length-1) {
            if(target == matrix[row][col]) {
                return true;
            } else if(target < matrix[row][col]) {
                col--;
            } else if(target > matrix[row][col]) {
                row++;
            }
        }
        return false;
    }
```











